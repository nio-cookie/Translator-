<!DOCTYPE html>
<html lang="my">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Translator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Google Fonts - Press Start 2P for pixel font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* iOS-style light gray */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }
        .app-container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* iOS-style rounded corners */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 420px; /* iPhone X width approx for mobile */
            height: 90vh; /* Fill most of the screen height for mobile */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Desktop and Tablet adjustments */
        @media (min-width: 768px) { /* md breakpoint for Tailwind */
            .app-container {
                max-width: 768px; /* Wider for tablets and desktops */
                height: 80vh; /* Adjust height for larger screens */
                max-height: 700px; /* Prevent it from getting too tall on very large screens */
            }
        }

        .app-header {
            background-color: #f8f8f8;
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
            font-weight: 600;
            color: #333;
            border-top-left-radius: 1.5rem;
            border-top-right-radius: 1.5rem;
            display: flex;
            justify-content: space-between; /* Distribute items */
            align-items: center;
        }
        .header-left, .header-right {
            flex-shrink: 0; /* Prevent shrinking */
            width: 80px; /* Fixed width for left/right sections to help center title */
            display: flex;
            align-items: center;
        }
        .header-left {
            justify-content: flex-start;
        }
        .header-right {
            justify-content: flex-end;
        }
        .app-header-title {
            flex-grow: 1; /* Allow title to take available space */
            text-align: center; /* Center the text within its own flex item */
        }
        .history-icon-button, .telegram-link-header {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: #007aff;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 24px; /* Ensure consistent size for icons */
            transition: transform 0.1s;
            text-decoration: none; /* For the link */
            font-weight: 500;
            gap: 0.25rem; /* Space between icon and text */
        }
        .history-icon-button {
            width: 24px; /* Fixed width for history icon button */
        }
        .telegram-link-header {
            /* No specific width here, let content define it within header-left */
        }
        .history-icon-button:hover, .telegram-link-header:hover {
            transform: scale(1.1);
        }
        .history-icon-button:active, .telegram-link-header:active {
            transform: scale(0.9);
        }
        .history-icon, .telegram-icon-header {
            fill: currentColor;
            width: 24px;
            height: 24px;
        }
        .pixel-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem; /* Smaller size for pixel effect */
            white-space: nowrap; /* Prevent wrapping */
            color: #007aff; /* Match link color */
        }
        .language-toggle {
            display: flex;
            justify-content: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e0e0e0;
            gap: 0.5rem;
        }
        .language-button {
            background-color: #e5e5ea;
            color: #333;
            padding: 0.5rem 1rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            font-weight: 500;
            flex: 1;
            text-align: center;
        }
        .language-button.active {
            background-color: #007aff;
            color: white;
        }
        .translation-area {
            flex-grow: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto; /* Allow scrolling for long history */
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .input-group textarea {
            border: 1px solid #d1d1d6;
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            resize: vertical; /* Allow vertical resizing */
            outline: none;
            transition: border-color 0.2s;
            min-height: 80px; /* Larger input area */
            max-height: 200px;
        }
        .input-group textarea:focus {
            border-color: #007aff;
        }
        .translate-button {
            background-color: #007aff;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }
        .translate-button:hover {
            background-color: #005bb5;
        }
        .translate-button:active {
            transform: scale(0.98);
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007aff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .output-area {
            background-color: #e5e5ea;
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            padding-right: 3rem; /* Add more padding to the right for the speak button */
            min-height: 80px; /* Larger output area */
            word-wrap: break-word;
            color: #333;
            font-size: 1rem;
            display: flex;
            align-items: center; /* Vertically center text */
            position: relative; /* For positioning the speak button */
        }
        .speak-button {
            background: #d1e7ff; /* Light blue background for prominence */
            border: 1px solid #007aff; /* Blue border */
            border-radius: 50%; /* Circular */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Subtle shadow */
            cursor: pointer;
            color: #007aff;
            position: absolute;
            bottom: 0.5rem; /* Position from bottom */
            right: 0.5rem; /* Position from right */
            width: 40px; /* Increased size for prominence */
            height: 40px; /* Increased size for prominence */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s, background-color 0.2s;
            z-index: 10; /* Ensure it's on top */
        }
        .speak-button:hover {
            transform: scale(1.1);
            background-color: #c0dfff; /* Lighter blue on hover */
        }
        .speak-button:active {
            transform: scale(0.9);
        }
        .speak-icon {
            fill: currentColor;
            width: 24px; /* Increased icon size */
            height: 24px; /* Increased icon size */
        }
        .speak-loading-spinner {
            border: 3px solid #f3f3f3; /* Thicker border for spinner */
            border-top: 3px solid #007aff; /* Thicker border for spinner */
            border-radius: 50%;
            width: 20px; /* Larger spinner */
            height: 20px; /* Larger spinner */
            animation: spin 1s linear infinite;
            display: none;
        }
        .history-section {
            margin-top: 1rem;
            border-top: 1px solid #e0e0e0;
            padding-top: 1rem;
            display: none; /* Hidden by default */
        }
        .history-section.visible {
            display: block; /* Show when visible class is added */
        }
        .history-section h3 {
            font-weight: 600;
            color: #333;
            margin-bottom: 0.75rem;
        }
        .history-list {
            max-height: 200px; /* Max height for history list */
            overflow-y: auto;
            background-color: #f8f8f8;
            border-radius: 0.75rem;
            padding: 0.5rem;
        }
        .history-item {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .history-item:last-child {
            border-bottom: none;
        }
        .history-item:hover {
            background-color: #e0e0e0;
        }
        .history-item .original-text {
            font-weight: 500;
            color: #555;
        }
        .history-item .translated-text {
            color: #007aff;
            margin-top: 0.25rem;
        }

        /* Responsive adjustments for mobile (max-width: 600px) */
        @media (max-width: 600px) {
            .app-container {
                height: 100vh;
                max-width: 100%;
                border-radius: 0; /* Full screen on small devices */
                box-shadow: none;
            }
            body {
                padding: 0;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-header">
            <!-- Telegram link in top-left -->
            <div class="header-left">
                <a href="https://t.me/nio_oe" target="_blank" class="telegram-link-header">
                    <svg class="telegram-icon-header" viewBox="0 0 24 24">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.71 7.33l-2.48 7.33c-.22.65-.4 1.05-.78 1.05-.33 0-.6-.2-.77-.42l-1.95-1.89-1.04 1.01c-.15.15-.27.27-.51.27-.25 0-.44-.19-.51-.35L6.6 12.8c-.2-.55-.04-.84.4-1.01l8.7-3.3c.4-.15.7-.05.6.22z"/>
                    </svg>
                    <span class="pixel-text">NioKoe</span>
                </a>
            </div>
            <span class="app-header-title">Translator</span>
            <div class="header-right">
                <button id="historyIconButton" class="history-icon-button" aria-label="View Translation History">
                    <!-- History Icon SVG -->
                    <svg class="history-icon" viewBox="0 0 24 24">
                        <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.51 0-2.91-.49-4.06-1.3l-1.42 1.42C8.36 20.42 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zM12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67V7z"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="language-toggle">
            <button id="burmeseToEnglishBtn" class="language-button active">Burmese &rarr; English</button>
            <button id="englishToBurmeseBtn" class="language-button">English &rarr; Burmese</button>
        </div>

        <div class="translation-area">
            <div class="input-group">
                <textarea id="inputText" placeholder="Enter text to translate..."></textarea>
            </div>

            <button id="translateButton" class="translate-button">
                Translate
                <span id="buttonSpinner" class="loading-spinner"></span>
            </button>

            <div class="output-area" id="outputText">
                <!-- Translated text will appear here -->
                <button id="speakButton" class="speak-button" style="display: none;">
                    <svg class="speak-icon" viewBox="0 0 24 24">
                        <path d="M12 4c-3.87 0-7 3.13-7 7v2c0 3.87 3.13 7 7 7s7-3.13 7-7v-2c0-3.87-3.13-7-7-7zm-1 14h2v-6h-2v6zm-1-8h4V7h-4v3z"/>
                    </svg>
                    <span id="speakSpinner" class="speak-loading-spinner"></span>
                </button>
            </div>

            <div id="historySection" class="history-section">
                <h3>Translation History</h3>
                <div id="historyList" class="history-list">
                    <!-- Translation history items will be appended here -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        const inputText = document.getElementById('inputText');
        const translateButton = document.getElementById('translateButton');
        const outputTextDiv = document.getElementById('outputText');
        const buttonSpinner = document.getElementById('buttonSpinner');
        const burmeseToEnglishBtn = document.getElementById('burmeseToEnglishBtn');
        const englishToBurmeseBtn = document.getElementById('englishToBurmeseBtn');
        const historyList = document.getElementById('historyList');
        const historySection = document.getElementById('historySection');
        const historyIconButton = document.getElementById('historyIconButton');
        const speakButton = document.getElementById('speakButton');
        const speakSpinner = document.getElementById('speakSpinner');
        const speakIcon = speakButton.querySelector('.speak-icon');

        let currentTranslationDirection = 'burmeseToEnglish'; // Default translation direction

        // Load history from localStorage
        let translationHistory = JSON.parse(localStorage.getItem('translationHistory')) || [];

        // Function to render history items
        function renderHistory() {
            historyList.innerHTML = ''; // Clear existing history
            if (translationHistory.length === 0) {
                historyList.innerHTML = '<p class="text-gray-500 text-center py-2">No history yet</p>';
                return;
            }
            translationHistory.forEach((item, index) => {
                const historyItemDiv = document.createElement('div');
                historyItemDiv.classList.add('history-item');
                historyItemDiv.innerHTML = `
                    <div class="original-text">${item.original}</div>
                    <div class="translated-text">${item.translated}</div>
                `;
                historyItemDiv.addEventListener('click', () => {
                    inputText.value = item.original;
                    // Directly set the text content, speak button will appear on translation
                    outputTextDiv.textContent = item.translated;
                    setTranslationDirection(item.direction);
                    historySection.classList.remove('visible');
                    // Manually trigger speak button visibility if text is present
                    if (outputTextDiv.textContent.trim() !== '') {
                        speakButton.style.display = 'flex';
                    } else {
                        speakButton.style.display = 'none';
                    }
                });
                historyList.prepend(historyItemDiv); // Add new items to the top
            });
        }

        // Function to save translation to history
        function saveToHistory(original, translated, direction) {
            translationHistory.unshift({ original, translated, direction }); // Add to the beginning
            // Limit history items (e.g., to 20)
            if (translationHistory.length > 20) {
                translationHistory = translationHistory.slice(0, 20);
            }
            localStorage.setItem('translationHistory', JSON.stringify(translationHistory));
            renderHistory(); // Re-render history after saving
        }

        // Helper function to convert base64 to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Helper function to convert PCM (Int16Array) to WAV Blob
        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1; // Mono audio
            const bytesPerSample = 2; // 16-bit PCM
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;

            const dataLength = pcmData.byteLength;
            const buffer = new ArrayBuffer(44 + dataLength); // 44 bytes for WAV header
            const view = new DataView(buffer);

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true); // ChunkSize
            writeString(view, 8, 'WAVE');

            // FMT sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
            view.setUint16(20, 1, true); // AudioFormat (1 for PCM)
            view.setUint16(22, numChannels, true); // NumChannels
            view.setUint32(24, sampleRate, true); // SampleRate
            view.setUint32(28, byteRate, true); // ByteRate
            view.setUint16(32, blockAlign, true); // BlockAlign
            view.setUint16(34, bytesPerSample * 8, true); // BitsPerSample

            // DATA sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true); // Subchunk2Size

            // Write PCM data
            const pcmBytes = new Uint8Array(pcmData.buffer);
            for (let i = 0; i < dataLength; i++) {
                view.setUint8(44 + i, pcmBytes[i]);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Function to play audio from a URL
        function playAudio(audioUrl) {
            const audio = new Audio(audioUrl);
            audio.play().catch(e => console.error("Error playing audio:", e));
        }

        // Function to speak translated text using TTS API
        async function speakTranslatedText(text, languageCode) {
            if (!text || text.trim() === '') {
                console.warn("TTS: No text to speak.");
                return;
            }

            speakIcon.style.display = 'none';
            speakSpinner.style.display = 'block';
            speakButton.disabled = true;
            console.log("Attempting to speak text:", text, "with language code:", languageCode);

            try {
                const payload = {
                    contents: [{
                        parts: [{ text: text }]
                    }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                // Using specified voices for Burmese and English
                                prebuiltVoiceConfig: { voiceName: languageCode === 'my-MM' ? "Puck" : "Kore" }
                            },
                            languageCode: languageCode // Explicitly set language code
                        }
                    },
                    model: "gemini-2.5-flash-preview-tts"
                };

                const apiKey = ""; // API key provided by Canvas environment
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

                let response;
                let retries = 0;
                const maxRetries = 3;
                const baseDelay = 500;

                while (retries < maxRetries) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        console.log(`TTS Fetch attempt ${retries + 1} response status:`, response.status);

                        if (response.ok) {
                            break;
                        } else if (response.status === 429) {
                            const delay = baseDelay * Math.pow(2, retries);
                            console.warn(`TTS Rate limit hit. Retrying in ${delay / 1000} seconds...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            retries++;
                        } else {
                            const errorData = await response.json();
                            throw new Error(`TTS API error: ${response.status} - ${errorData.error.message || response.statusText}`);
                        }
                    } catch (error) {
                        if (retries < maxRetries - 1) {
                            const delay = baseDelay * Math.pow(2, retries);
                            console.error(`TTS Fetch error: ${error.message}. Retrying in ${delay / 1000} seconds...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            retries++;
                        } else {
                            throw error;
                        }
                    }
                }

                if (!response || !response.ok) {
                    throw new Error("Failed to get TTS response after multiple retries.");
                }

                const result = await response.json();
                console.log("TTS API raw response:", result); // Log raw response
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                console.log("TTS API part:", part); // Log the 'part'
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;
                console.log("TTS audioData:", audioData ? "present" : "missing", "mimeType:", mimeType); // Check data and mimeType

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    console.log("TTS audio data and mimeType are valid. Proceeding to convert and play.");
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000; // Default to 16kHz if not found
                    console.log("TTS sampleRate:", sampleRate);

                    const pcmData = base64ToArrayBuffer(audioData);
                    // API returns signed PCM16 audio data.
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    console.log("TTS audioUrl created:", audioUrl);
                    playAudio(audioUrl);
                } else {
                    console.error("TTS: Unexpected response structure or mimeType. Check API response for details.");
                    // Do not overwrite outputTextDiv, as it contains the translation
                }

            } catch (error) {
                console.error("Error during TTS generation:", error);
                // Do not overwrite outputTextDiv, as it contains the translation
            } finally {
                speakSpinner.style.display = 'none';
                speakIcon.style.display = 'block';
                speakButton.disabled = false;
            }
        }

        // Function to perform translation
        async function translateText() {
            const userText = inputText.value.trim();
            if (userText === '') {
                outputTextDiv.textContent = "Please enter text to translate.";
                speakButton.style.display = 'none'; // Hide speak button if no text
                return;
            }

            outputTextDiv.textContent = ''; // Clear previous translation
            speakButton.style.display = 'none'; // Hide speak button during translation
            buttonSpinner.style.display = 'block'; // Show loading spinner
            translateButton.disabled = true; // Disable button during loading

            try {
                let prompt;
                // Instruct Gemini to handle slang and informal language
                if (currentTranslationDirection === 'burmeseToEnglish') {
                    prompt = `Translate the following Burmese text to English, accurately translating any slang or informal language, providing only the translated text: "${userText}"`;
                } else {
                    prompt = `Translate the following English text to Burmese, accurately translating any slang or informal language, providing only the translated text: "${userText}"`;
                }

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                const apiKey = ""; // API key provided by Canvas environment
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                let response;
                let retries = 0;
                const maxRetries = 3; // Reduced retries for faster failure/success
                const baseDelay = 500; // Base delay for exponential backoff (0.5 seconds)

                while (retries < maxRetries) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            break; // Success, exit loop
                        } else if (response.status === 429) { // Too Many Requests (Rate Limit)
                            const delay = baseDelay * Math.pow(2, retries);
                            console.warn(`Translation Rate limit hit. Retrying in ${delay / 1000} seconds...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            retries++;
                        } else {
                            // Other HTTP errors
                            const errorData = await response.json();
                            throw new Error(`API error: ${response.status} - ${errorData.error.message || response.statusText}`);
                        }
                    } catch (error) {
                        if (retries < maxRetries - 1) {
                            const delay = baseDelay * Math.pow(2, retries);
                            console.error(`Translation Fetch error: ${error.message}. Retrying in ${delay / 1000} seconds...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            retries++;
                        } else {
                            throw error; // Re-throw error if max retries reached
                        }
                    }
                }

                if (!response || !response.ok) {
                    throw new Error("Failed to get a successful response after multiple retries.");
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const translatedText = result.candidates[0].content.parts[0].text;
                    outputTextDiv.textContent = translatedText;
                    saveToHistory(userText, translatedText, currentTranslationDirection);
                    speakButton.style.display = 'flex'; // Show speak button after successful translation
                } else {
                    outputTextDiv.textContent = "Translation failed. Please try again.";
                    console.error("Unexpected API response structure:", result);
                }

            } catch (error) {
                console.error("Error during translation:", error);
                outputTextDiv.textContent = "An error occurred during translation. Please try again later.";
            } finally {
                buttonSpinner.style.display = 'none'; // Hide loading spinner
                translateButton.disabled = false; // Enable button
            }
        }

        // Event listeners
        translateButton.addEventListener('click', translateText);
        inputText.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) { // Allow Shift+Enter for new line
                e.preventDefault();
                translateText();
            }
        });

        // Function to set translation direction
        function setTranslationDirection(direction) {
            currentTranslationDirection = direction;
            if (direction === 'burmeseToEnglish') {
                burmeseToEnglishBtn.classList.add('active');
                englishToBurmeseBtn.classList.remove('active');
                inputText.placeholder = "ဘာသာပြန်လိုသော စာသားကို ရိုက်ထည့်ပါ...";
            } else {
                englishToBurmeseBtn.classList.add('active');
                burmeseToEnglishBtn.classList.remove('active');
                inputText.placeholder = "Enter text to translate...";
            }
            outputTextDiv.textContent = ''; // Clear output when direction changes
            speakButton.style.display = 'none'; // Hide speak button when direction changes
        }

        burmeseToEnglishBtn.addEventListener('click', () => setTranslationDirection('burmeseToEnglish'));
        englishToBurmeseBtn.addEventListener('click', () => setTranslationDirection('englishToBurmese'));

        // Toggle history section visibility
        historyIconButton.addEventListener('click', () => {
            historySection.classList.toggle('visible');
            if (historySection.classList.contains('visible')) {
                renderHistory(); // Render history only when it becomes visible
            }
        });

        // Speak button event listener
        speakButton.addEventListener('click', () => {
            const textToSpeak = outputTextDiv.textContent;
            let languageCode = '';
            // Determine language code based on current translation direction
            if (currentTranslationDirection === 'burmeseToEnglish') {
                languageCode = 'en-US'; // Translated text is English
            } else {
                languageCode = 'my-MM'; // Translated text is Burmese
            }
            speakTranslatedText(textToSpeak, languageCode);
        });

        // Initial setup
        setTranslationDirection('burmeseToEnglish'); // Set default direction and placeholder
        // History is not rendered initially, only when the icon is clicked
    </script>
</body>
</html>

